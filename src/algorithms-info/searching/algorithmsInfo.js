const info = [
    {
        key: 'LINEAR_SEARCH',
        name: 'Линейный поиск',
        description: 'Для нахождения некоторого элемента (ключа) в заданном неупорядоченном массиве используется алгоритм линейного (последовательного) поиска. Он работает как с неотсортированными массивами, так и отсортированными, но для вторых существуют алгоритмы эффективнее линейного поиска. Эту неэффективность компенсируют простая реализация алгоритма и сама возможность применять его к неупорядоченным последовательностям. Здесь, а также при рассмотрении всех других алгоритмов поиска, будем полагать, что в качестве ключа выступает некоторая величина, по мере выполнения алгоритма, сравниваемая именно со значениями элементов массива.',
        time: 'O(n)',
        space: 'O(1)'
    },
    {
        key: 'BINARY_SEARCH',
        name: 'Бинарный поиск',
        description: 'Бинарный поиск — тип поискового алгоритма, который последовательно делит пополам заранее отсортированный массив данных, чтобы обнаружить нужный элемент. Другие его названия — двоичный поиск, метод половинного деления, дихотомия. Основная последовательность действий алгоритма выглядит так: 1) Делим массив пополам и находим середину. 2) Сравниваем срединный элемент с заданным искомым элементом. 3) Если искомое число больше среднего — продолжаем поиск в правой части массива (если он отсортирован по возрастанию): делим ее пополам, повторяя пункт 2. Если же заданное число меньше — алгоритм продолжит поиск в левой части массива, снова возвращаясь к пункту 2.',
        time: 'O(n log n)',
        space: 'O(1)'
    },
    {
        key: 'JUMP_SEARCH',
        name: 'Поиск прыжками',
        description: 'От двоичного поиска этот алгоритм отличает движение исключительно вперёд. Имейте в виду, что такой поиск требует отсортированной коллекции. Мы прыгаем вперёд на интервал sqrt(arraylength), пока не достигнем элемента большего, чем текущий элемент или конца массива. При каждом прыжке записывается предыдущий шаг. Прыжки прекращаются, когда найден элемент больше искомого. Затем запускаем линейный поиск между предыдущим и текущим шагами. Это уменьшает поле поиска и делает линейный поиск жизнеспособным вариантом.',
        time: 'O(√n)',
        space: 'O(1)'
    }
]

export default info;